---
title: "Final-Hamden-assessed-value-fairness"
author: "Lee-Ann Kao, Jake Todd, Ashley Yen"
date: "2025-09-18"
output: pdf_document
---

```{r}
# load libraries
library(dplyr)
library(readxl)
library(ggplot2)
library(tidyverse)
library(corrplot)
library(MASS)
library(leaflet)
```

# read in and join data
```{r}
# read in CT property and sales data
sale_data <- read_excel("sales_data.xlsx")
hamden_data <- read_csv("hamden_data_complete.csv")

# glance at data
head(hamden_data)
head(sale_data)
names(sale_data)
names(hamden_data)

# outer join
sale_data$Location <- paste(sale_data$`Property Number`, sale_data$`Street Name`)
merged <- left_join(hamden_data, sale_data, by = "Location")

# glance at data
head(merged)

# models for sales values
names(merged)
head(merged$Location)
```

# look at data relationships
```{r}
# coerce to numeric (strip $ and commas if present)
merged <- merged %>%
  mutate(
    Assessed.Total = readr::parse_number(as.character(Assessed.Total)),
    Sale.Price     = readr::parse_number(as.character(Sale.Price))
  )%>%
  filter(Sale.Price > 0)


# now compute ratios
merged <- merged %>%
  mutate(
    ASR = Assessed.Total / Sale.Price,
    Equalized_Ratio = (Assessed.Total / 0.70) / Sale.Price
  )

# histogram of ASR
merged$ASR
merged$Assessed.Total
head(merged$ASR)
str(merged$ASR)
summary(merged$ASR)
merged <- merged %>%
  filter(ASR < 1)

# plot from the correct dataframe
ggplot(merged, aes(x = ASR)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "white") +
  geom_vline(xintercept = 0.70, color = "red", linetype = "dashed") +
  labs(
    title = "Hamden Assessment-to-Sale Ratio (ASR)",
    x = "Assessment-to-Sale Ratio",
    y = "Count"
  )
```

# prep data
```{r}
model_data <- merged %>%
  mutate(
    Sale     = readr::parse_number(as.character(Sale.Price)),
    Assessed.Total = readr::parse_number(as.character(Assessed.Total)),
    Living.Area    = as.numeric(Living.Area),
    Land.Acres     = as.numeric(Land.Acres),
    Number.of.Bedroom = as.numeric(Number.of.Bedroom),
    Number.of.Baths   = as.numeric(Number.of.Baths),
    Number.of.Half.Baths = as.numeric(Number.of.Half.Baths)
  ) %>% 
  rename(`Sale_2024` = `Sale Price`)
```


# model selection
```{r}
# make correlation matrix
cor1 <- cor(model_data[, c('Pre.Yr.Assessed.Total', 'Land.Acres', 'Living.Area', 'Effective.Area', 'Total.Rooms', 'Number.of.Bedroom', 'Number.of.Baths', 'Number.of.Half.Baths', 'Sale.Price', 'ayb', 'eyb')], use = "pairwise.complete.obs")

corrplot.mixed(cor1, lower.col = "black", upper = "ellipse", tl.col = "black", number.cex = .7, tl.pos = "lt", tl.cex=.7, sig.level = .05)

# limit to potentially relevant variables
model_data2 <- model_data[, c('Land.Acres', 'Living.Area', 'Effective.Area', 'Total.Rooms', 'Number.of.Bedroom', 'Number.of.Baths', 'Sale.Price', 'Sale_2024', 'ayb', 'eyb')]

# perform best subsets regression
full_model <- lm(log(Sale_2024) ~ ., data = model_data2)
null_model <- lm(log(Sale_2024) ~ 1, data = model_data2)
n <- nrow(model_data2)

# stepwise regression using BIC
stepwise_bic_model <- stepAIC(null_model,
                              direction = "both",
                              scope = list(upper = full_model, lower = null_model),
                              k = log(n))
summary(stepwise_bic_model)

# stepwise regression AIC
stepwise_aic_model <- stepAIC(full_model, direction = "both", trace = FALSE)
summary(stepwise_aic_model)
```
# model training
```{r}
for(i in 1:nrow(model_data)){
  model_data$Sale.Year[i] <- substr(model_data$Sale.Date[i], nchar(model_data$Sale.Date[i]) - 3, nchar(model_data$Sale.Date[i]))
}
model_data$Sale.Year <- as.numeric(model_data$Sale.Year)

train_data = model_data[!is.na(model_data$`Sale_2024`), ]
test_data = model_data[is.na(model_data$`Sale_2024`), ]

for(i in 1:nrow(train_data)){
  train_data$PID[i] <- str_split(train_data$link[i],"-")[[1]][2]
}
train_data$PID <- as.numeric(train_data$PID)

library(rvest)

for(i in 1:nrow(train_data)){
  temp_html <- read_html(paste0('Hamden_Sept2025/',train_data$PID[i],'.html'))
  tables <- temp_html %>% 
    html_elements("table") %>%   
    html_table(fill = TRUE)
  sale_table <- tables[[6]]
  train_data$Sale.Date[i] <- sale_table$`Sale Date`[2]
  train_data$Sale.Price[i] <- sale_table$`Sale Price`[2]
}

for(i in 1:nrow(train_data)){
  train_data$Sale.Year[i] <- substr(train_data$Sale.Date[i], nchar(train_data$Sale.Date[i]) - 3, nchar(train_data$Sale.Date[i]))
}
train_data$Sale.Year <- as.numeric(train_data$Sale.Year)

for(i in 1:nrow(train_data)){
  train_data$Sale.Price[i] <- substr(train_data$Sale.Price[i], 2, nchar(train_data$Sale.Price[i]))
}

#training dataset model

fit <- lm(log(Sale_2024) ~ Land.Acres + Number.of.Baths + Number.of.Bedroom + eyb,
          data = train_data)

summary(fit)
pred_sale <- predict(fit, newdata = test_data) 
test_data$Sale_2024 <- pred_sale
```


# plot
```{r}
ggplot(test_data, aes(x = Sale_2024)) +
  geom_point(aes(y = Sale.Price), color = "blue", alpha = 0.5) +
  geom_point(aes(y = Assessed.Total / 0.70), color = "red", alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  labs(title = "Predicted vs Actual vs Assessed Market Values",
       x = "Predicted Price (Model)",
       y = "Value",
       caption = "Blue = Actual Sale, Red = Assessor (Equalized)")

test_data$Appraised <- test_data$Assessed.Total / 0.70
test_data$residual <- test_data$Sale_2024 - test_data$Appraised
test_data$residual_normalized <- test_data$residual/test_data$Appraised
test_data$residual_normalized

ggplot(data = train_data, aes(x = `Current Year Appraisal`, y = Sale_2024)) + geom_point() + geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red")

ggplot(data = test_data, aes(x = Appraised, y = Sale_2024)) + geom_point() + geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red")
```


# map
```{r}
# Read the object from the file
centroids <- readRDS("centroids.no.geometry.rds")
hamden_geo <- read_csv("final_data.csv")

# See what type of object it is
class(centroids)

# Peek at the data
head(centroids)
head(hamden_geo)

# Example with left join (keep all rows from hamden_geo)
hamden_joined <- hamden_geo %>%
  left_join(centroids, by = c("link" = "Link"))

# Check result
hamden_joined
```

```{r}
leaflet(hamden_joined) %>%
  addTiles() %>%  # adds OpenStreetMap background
  addCircleMarkers(
    lng = ~point.x, lat = ~point.y,
    radius = 5,
    color = ~colorNumeric(palette = c("blue","white","red"), domain = hamden_joined$ASR)(ASR),
    fillOpacity = 0.7,
    popup = ~paste0(Location.y, "<br>ASR = ", round(ASR, 2))
  ) %>%
  addLegend(
    "bottomright", 
    pal = colorNumeric(c("blue","white","red"), hamden_joined$ASR),
    values = ~ASR,
    title = "ASR",
    opacity = 1
  )
```

