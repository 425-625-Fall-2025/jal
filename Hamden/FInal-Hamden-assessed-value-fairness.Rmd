---
title: "Final-Hamden-assessed-value-fairness"
author: "Lee-Ann Kao, Jake Todd, Ashley Yen"
date: "2025-09-18"
output: pdf_document
---

```{r}
# load libraries
library(dplyr)
library(readxl)
library(ggplot2)
library(tidyverse)
library(corrplot)
library(MASS)
library(leaflet)
```
A Hamden homeowner saw a large assessment increase shortly after purchasing and wanted to know whether the new assessed value is fair. In order to answer this question, we attempted to recreate the assessor valuation process, by using recent sales to build a pricing model, then applying it to all properties. By comparing predictions to assessments, we determined whether the assessor's values align with our estimate of value.  

# read in and join data
```{r}
# read in CT property and sales data
sale_data <- read_excel("sales_data.xlsx")
hamden_data <- read_csv("final_data.csv")

# glance at data
head(hamden_data)
head(sale_data)
names(sale_data)
names(hamden_data)

# outer join
sale_data$Location <- paste(sale_data$`Property Number`, sale_data$`Street Name`)
merged <- left_join(hamden_data, sale_data, by = "Location")

# glance at data
head(merged)

# models for sales values
names(merged)
head(merged$Location)
```
The histogram below shows the distribution of ASR (Assessed Value/Sale Price ratio). 

# look at data relationships
```{r}
# coerce to numeric (strip $ and commas if present)
merged <- merged %>%
  mutate(
    Assessed.Total = readr::parse_number(as.character(Assessed.Total)),
    Sale.Price     = readr::parse_number(as.character(Sale.Price))
  )%>%
  filter(Sale.Price > 0)


# now compute ratios
merged <- merged %>%
  mutate(
    ASR = Assessed.Total / Sale.Price,
    Equalized_Ratio = (Assessed.Total / 0.70) / Sale.Price
  )

# histogram of ASR
merged$ASR
merged$Assessed.Total
head(merged$ASR)
str(merged$ASR)
summary(merged$ASR)
merged <- merged %>%
  filter(ASR < 1)

# plot from the correct dataframe
ggplot(merged, aes(x = ASR)) +
  geom_histogram(binwidth = 0.05, fill = "steelblue", color = "white") +
  geom_vline(xintercept = 0.70, color = "red", linetype = "dashed") +
  labs(
    title = "Hamden Assessment-to-Sale Ratio (ASR)",
    x = "Assessment-to-Sale Ratio",
    y = "Count"
  )
```

The histogram is approximately centered around 0.70, suggesting that on average, properties are properly assessed. This is because the statutory level of assessed value is 70% of fair market value in Connecticut. 

# prep data
```{r}
model_data <- merged %>%
  mutate(
    Sale     = readr::parse_number(as.character(Sale.Price)),
    Assessed.Total = readr::parse_number(as.character(Assessed.Total)),
    Living.Area    = as.numeric(Living.Area),
    Land.Acres     = as.numeric(Land.Acres),
    Number.of.Bedroom = as.numeric(Number.of.Bedroom),
    Number.of.Baths   = as.numeric(Number.of.Baths),
    Number.of.Half.Baths = as.numeric(Number.of.Half.Baths)
  )
```

We first performed correlation analysis and best subsets regression to identify which property features are most predictive of sale price.

# model selection
```{r}
# make correlation matrix
cor1 <- cor(model_data[, c('Pre.Yr.Assessed.Total', 'Land.Acres', 'Living.Area', 'Effective.Area', 'Total.Rooms', 'Number.of.Bedroom', 'Number.of.Baths', 'Number.of.Half.Baths', 'Sale.Price', 'ayb', 'eyb')], use = "pairwise.complete.obs")

corrplot.mixed(cor1, lower.col = "black", upper = "ellipse", tl.col = "black", number.cex = .7, tl.pos = "lt", tl.cex=.7, sig.level = .05)

# limit to potentially relevant variables
model_data2 <- model_data[, c('Land.Acres', 'Living.Area', 'Effective.Area', 'Total.Rooms', 'Number.of.Bedroom', 'Number.of.Baths', 'Sale.Price', 'Sale_2024', 'ayb', 'eyb')]

# perform best subsets regression
full_model <- lm(log(Sale_2024) ~ ., data = model_data2)
null_model <- lm(log(Sale_2024) ~ 1, data = model_data2)
n <- nrow(model_data2)

# stepwise regression using BIC
stepwise_bic_model <- stepAIC(null_model,
                              direction = "both",
                              scope = list(upper = full_model, lower = null_model),
                              k = log(n))
summary(stepwise_bic_model)

# stepwise regression AIC
stepwise_aic_model <- stepAIC(full_model, direction = "both", trace = FALSE)
summary(stepwise_aic_model)
```

The correlation plot includes the following variables: Previous Year Assessed Total, Land Acres, Living Area, Effective Area, Total Rooms, Number of Bedroom, Number of Baths, Number of Half Baths, Sale Price, ayb, and eyb. All pairs of variables except Number of Baths and Number of Half Baths had positive or neutral correlations. Living Area and Previous Year Assessed Total, Effective Area and Previous Year Assessed Total, and Living Area and Effective Area had the strongest, positive correlations. Previous Year Assessed Total was also strongly correlated with Total Rooms and Baths. 

Next, we used BIC-based stepwise selection and AIC-based stepwise selection to decide which predictors to use in our model. 

AIC-based stepwise selection chose a model with 3 predictors: Sale Price, eyb, and Total Rooms, yielding an AIC = -1955.5 and R^2 of about 0.90. 


1. Based on Adjusted R^2, the model with 9 predictors (Land Acres, Living Area, Effective Area, Total Rooms, Number of Bedrooms, Number of Baths, ayb, eyb, and Sale Year) is best. It yields an Adjusted R^2 of 0.563 and demonstrates that Sale Year is strongly predictive, and many of the variables matter.

2. Based on BIC, the model with 4 predictors (Land Acres, Effective Area, Total Rooms, and Sale Year) is best. This model yielded an Adjusted R^2 that is almost the same as the first model (0.557).  

3.  Based on Mallows' Cp, the model with all 9 variables is best.

# model training
```{r}
for(i in 1:nrow(model_data)){
  model_data$Sale.Year[i] <- substr(model_data$Sale.Date[i], nchar(model_data$Sale.Date[i]) - 3, nchar(model_data$Sale.Date[i]))
}
model_data$Sale.Year <- as.numeric(model_data$Sale.Year)

train_data = model_data[!is.na(model_data$`Sale_2024`), ]
test_data = model_data[is.na(model_data$`Sale_2024`), ]

for(i in 1:nrow(train_data)){
  train_data$PID[i] <- str_split(train_data$link[i],"-")[[1]][2]
}
train_data$PID <- as.numeric(train_data$PID)

library(rvest)

for(i in 1:nrow(train_data)){
  temp_html <- read_html(paste0('Hamden_Sept2025/',train_data$PID[i],'.html'))
  tables <- temp_html %>% 
    html_elements("table") %>%   
    html_table(fill = TRUE)
  sale_table <- tables[[6]]
  train_data$Sale.Date[i] <- sale_table$`Sale Date`[2]
  train_data$Sale.Price[i] <- sale_table$`Sale Price`[2]
}

for(i in 1:nrow(train_data)){
  train_data$Sale.Year[i] <- substr(train_data$Sale.Date[i], nchar(train_data$Sale.Date[i]) - 3, nchar(train_data$Sale.Date[i]))
}
train_data$Sale.Year <- as.numeric(train_data$Sale.Year)

for(i in 1:nrow(train_data)){
  train_data$Sale.Price[i] <- substr(train_data$Sale.Price[i], 2, nchar(train_data$Sale.Price[i]))
}

#training dataset model

fit <- lm(log(Sale_2024) ~ Land.Acres + Number.of.Baths + Number.of.Bedroom + eyb,
          data = train_data)

summary(fit)
pred_sale <- predict(fit, newdata = test_data) 
test_data$Sale_2024 <- pred_sale
```


# plot
```{r}
ggplot(test_data, aes(x = Sale_2024)) +
  geom_point(aes(y = Sale.Price), color = "blue", alpha = 0.5) +
  geom_point(aes(y = Assessed.Total / 0.70), color = "red", alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  labs(title = "Predicted vs Actual vs Assessed Market Values",
       x = "Predicted Price (Model)",
       y = "Value",
       caption = "Blue = Actual Sale, Red = Assessor (Equalized)")

test_data$Appraised <- test_data$Assessed.Total / 0.70
test_data$residual <- test_data$Sale_2024 - test_data$Appraised
test_data$residual_normalized <- test_data$residual/test_data$Appraised
test_data$residual_normalized

ggplot(data = train_data, aes(x = `Current Year Appraisal`, y = Sale_2024)) + geom_point() + geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red")

ggplot(data = test_data, aes(x = Appraised, y = Sale_2024)) + geom_point() + geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red")
```


# map
```{r}
# Read the object from the file
centroids <- readRDS("centroids.no.geometry.rds")
hamden_geo <- read_csv("final_data.csv")

# See what type of object it is
class(centroids)

# Look at the data
head(centroids)
head(hamden_geo)

# Example with left join (keep all rows from hamden_geo)
hamden_joined <- hamden_geo %>%
  left_join(centroids, by = c("link" = "Link"))

# Check result
hamden_joined
```

```{r}
leaflet(hamden_joined) %>%
  addTiles() %>%  # adds OpenStreetMap background
  addCircleMarkers(
    lng = ~point.x, lat = ~point.y,
    radius = 5,
    color = ~colorNumeric(palette = c("blue","white","red"), domain = hamden_joined$ASR)(ASR),
    fillOpacity = 0.7,
    popup = ~paste0(Location.y, "<br>ASR = ", round(ASR, 2))
  ) %>%
  addLegend(
    "bottomright", 
    pal = colorNumeric(c("blue","white","red"), hamden_joined$ASR),
    values = ~ASR,
    title = "ASR",
    opacity = 1
  )
```

